<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>WebDir</title>
    <link rel="icon" href="data:," />
    <style>
      /* Light theme (default) */
      :root {
        --primary-color: #3498db;
        --primary-color-rgb: 52, 152, 219;
        --hover-color: #2980b9;
        --text-color: #333;
        --border-color: #ddd;
        --bg-color: #f8f9fa;
        --toolbar-bg: #ffffff;
        --row-hover-bg: #f1f3f5;
        --table-row-bg: #ffffff;
        --table-header-bg: #f8f9fa;
        --control-panel-bg: #f8f9fa;
        --dialog-bg: #ffffff;
        --success-color: #2ecc71;
        --danger-color: #e74c3c;
        --warning-color: #f39c12;
        --info-color: #3498db;
        --directory-color: #f1c40f;
        --file-color: #95a5a6;
        --editor-bg: #ffffff;
        --editor-text: #333333;
        --input-bg: #ffffff;
        --filter-bg: #ffffff;
        --filter-border: rgba(0, 0, 0, 0.1);
        --dialog-shadow: rgba(0, 0, 0, 0.1);
        --toast-bg: #ffffff;
        --tooltip-bg: #333;
        --tooltip-color: #fff;
        --checkbox-invert: 0;
        --parent-dir-bg: #f8f9fa;
        --parent-dir-color: #333;
        --parent-dir-border: #ddd;
        --parent-dir-hover: #e9ecef;
        --button-bg: #f8f9fa;
        --button-color: #333;
        --button-color-rgb: 51, 51, 51;
        --button-border: #ddd;
        --button-hover-bg: #e9ecef;
      }

      /* Dark theme */
      [data-theme="dark"] {
        --primary-color: #4ea6e0;
        --primary-color-rgb: 78, 166, 224;
        --hover-color: #3498db;
        --text-color: #e0e0e0;
        --border-color: #444;
        --bg-color: #222;
        --toolbar-bg: #2c2c2c;
        --row-hover-bg: #383838;
        --table-row-bg: #2a2a2a;
        --table-header-bg: #333;
        --control-panel-bg: #333;
        --dialog-bg: #2c2c2c;
        --success-color: #2ecc71;
        --danger-color: #ff5349;
        --warning-color: #ffb347;
        --info-color: #4ea6e0;
        --directory-color: #f5d76e;
        --file-color: #bdc3c7;
        --editor-bg: #1e1e1e;
        --editor-text: #e0e0e0;
        --input-bg: #1e1e1e;
        --filter-bg: #2c2c2c;
        --filter-border: rgba(255, 255, 255, 0.1);
        --dialog-shadow: rgba(0, 0, 0, 0.5);
        --toast-bg: #2c2c2c;
        --tooltip-bg: #4c4c4c;
        --tooltip-color: #e0e0e0;
        --checkbox-invert: 0.8;
        --parent-dir-bg: #333;
        --parent-dir-color: #e0e0e0;
        --parent-dir-border: #444;
        --parent-dir-hover: #444;
        --button-bg: #333;
        --button-color: #e0e0e0;
        --button-color-rgb: 224, 224, 224;
        --button-border: #444;
        --button-hover-bg: #444;
      }

      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
          Helvetica, Arial, sans-serif;
        color: var(--text-color);
        background: var(--bg-color);
        line-height: 1.6;
      }

      .container {
        max-width: 1200px;
        margin: 0 auto;
        padding: 20px;
        min-width: 536px;
      }

      header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 20px;
        padding-bottom: 10px;
        border-bottom: 1px solid var(--border-color);
      }

      header h1 {
        color: var(--primary-color);
        font-size: 24px;
      }

      .control-container {
        display: flex;
        flex-direction: column;
        padding: 0px 15px;
        margin-bottom: 20px;
        background-color: var(--control-panel-bg);
        border-radius: 4px;
        border: 1px solid var(--border-color);
      }

      /* Breadcrumb styles */
      .breadcrumb {
        padding: 8px 0px;
        border-bottom: 1px solid var(--border-color);
        /* background-color: white;
        border-radius: 4px;
        border: 1px solid var(--border-color); */
      }

      .breadcrumb ol {
        display: flex;
        flex-wrap: wrap;
        list-style: none;
      }

      .breadcrumb li {
        display: inline-flex;
        align-items: center;
      }

      .breadcrumb li:not(:last-child)::after {
        content: "/";
        margin: 0 8px;
        color: #ccc;
      }

      .breadcrumb a {
        color: var(--primary-color);
        text-decoration: none;
      }

      .breadcrumb a:hover {
        color: var(--hover-color);
        text-decoration: underline;
      }

      /* Control bar styles */
      .control-bar {
        display: flex;
        flex-wrap: wrap;
        gap: 6px;
        padding: 10px 0px;
        /* background-color: var(--control-panel-bg);
        border-radius: 4px;
        border: 1px solid var(--border-color); */
        align-items: center;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
      }

      .btn {
        display: inline-flex;
        align-items: center;
        padding: 6px 6px;
        background-color: var(--primary-color);
        color: white;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        font-size: 14px;
        transition: background-color 0.2s;
      }

      .btn:hover {
        background-color: var(--hover-color);
      }

      .btn:disabled {
        background-color: var(--button-bg);
        cursor: not-allowed;
      }

      .btn svg {
        margin-right: 5px;
        width: 16px;
        height: 16px;
      }

      .btn.btn-parent {
        background-color: var(--parent-dir-bg);
        color: var(--parent-dir-color);
        padding-left: 4px;
        padding-right: 4px;
      }

      .btn.btn-parent:hover {
        background-color: var(--parent-dir-hover);
      }

      .filter-container {
        flex-grow: 1;
        position: relative;
      }

      .filter-input {
        width: 100%;
        padding: 6px 12px;
        padding-left: 30px;
        border: 1px solid var(--border-color);
        border-radius: 4px;
        font-size: 14px;
      }

      .filter-container svg {
        position: absolute;
        left: 8px;
        top: 50%;
        transform: translateY(-50%);
        color: #888;
        width: 16px;
        height: 16px;
      }

      .selection-badge {
        background-color: var(--primary-color);
        color: white;
        border-radius: 10px;
        padding: 2px 8px;
        font-size: 12px;
        font-weight: bold;
      }

      .file-table-container {
        overflow-x: auto;
      }

      /* Table styles */
      .file-table {
        width: 100%;
        border-collapse: collapse;
        border-color: var(--border-color);
        background-color: white;
        border-radius: 4px;
        overflow: hidden;
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        table-layout: fixed;
        white-space: nowrap;
        min-width: 700px;
      }

      .file-table th,
      .file-table td {
        padding: 10px 15px;
        text-align: left;
        border-bottom: 1px solid var(--border-color);
        overflow: hidden;
        vertical-align: middle;
      }

      .file-table th {
        background-color: #f5f5f5;
        font-weight: 600;
        -webkit-user-select: none;
        user-select: none;
        cursor: pointer;
        position: relative;
      }

      /* Style for checkbox cells to center contents */
      .file-table th:first-child, /* Apply to header too */
      .file-table td:first-child {
        /* Width for the checkbox column */
        width: 45px; /* Adjust as needed */
        vertical-align: middle;
        text-align: center;
      }

      /* --- Name Column Adjustments --- */

      .file-table th[data-sort="name"] {
        width: 50%;
      }

      .file-table th[data-sort="size"] {
        width: 90px;
      }

      .file-table th[data-sort="permission"] {
        width: 120px;
      }

      .file-table th[data-sort="modTime"] {
        width: 190px;
      }

      [data-theme="dark"] .file-table {
        background-color: var(--table-row-bg); /* Ensure consistency */
        border-color: var(--border-color);
      }

      [data-theme="dark"] .file-table tr:nth-child(even) td {
        background-color: var(--row-hover-bg);
      }

      [data-theme="dark"] .file-table tr:hover td {
        background-color: var(--row-hover-bg);
      }

      .file-table th:hover {
        background-color: #eee;
      }

      .file-table th.sorted::after {
        content: "";
        display: inline-block;
        margin-left: 6px;
        width: 0;
        height: 0;
      }

      .file-table th.sorted.asc::after {
        border-left: 5px solid transparent;
        border-right: 5px solid transparent;
        border-bottom: 5px solid var(--text-color);
      }

      .file-table th.sorted.desc::after {
        border-left: 5px solid transparent;
        border-right: 5px solid transparent;
        border-top: 5px solid var(--text-color);
      }

      .file-table tbody tr:hover {
        background-color: #f5f5f5;
      }

      .file-table .filename {
        display: flex;
        align-items: center;
        color: var(--text-color);
        overflow: hidden;
        width: 100%;
      }

      /* Ensure SVG icons are properly aligned */
      .file-table .filename svg {
        vertical-align: middle;
        display: inline-block;
      }

      .file-table .filename a {
        color: var(--text-color);
        text-decoration: none;
        margin-left: 6px;

        flex-grow: 1; /* Allow the link to take up available space */
        min-width: 0; /* Crucial: Allows the link to shrink below content size */
        white-space: nowrap; /* Prevent text wrapping */
        overflow: hidden; /* Hide overflowing text */
        text-overflow: ellipsis; /* Show ellipsis (...) */
        display: block; /* Or inline-block. Needed for overflow/text-overflow */
      }

      .file-table .filename a:hover {
        color: var(--primary-color);
        text-decoration: underline;
      }

      /* Style for filename when checkbox is focused */
      .file-table tr:has(input[type="checkbox"]:focus) .filename a {
        text-decoration: underline;
      }

      /* Improve visibility of hover in dark mode */
      [data-theme="dark"] .file-table tr:hover td {
        background-color: #444;
      }

      .file-table .icon {
        width: 20px;
        height: 20px;
        margin-right: 8px;
      }

      .file-table .checkbox {
        width: 18px;
        height: 18px;
        cursor: pointer;
        vertical-align: middle;
      }

      /* Style for checkbox cells to center contents */
      .file-table td:first-child {
        vertical-align: middle;
        text-align: center;
      }

      /* Dialog styles */
      .dialog-overlay {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background-color: rgba(0, 0, 0, 0.5);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 1000;
        opacity: 0;
        visibility: hidden;
        transition: opacity 0.2s, visibility 0.2s;
      }

      .dialog-overlay.active {
        opacity: 1;
        visibility: visible;
      }

      .dialog {
        background-color: white;
        border-radius: 8px;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        width: 100%;
        max-width: 500px;
        padding: 20px;
        transform: translateY(-20px);
        transition: transform 0.2s;
      }

      .dialog-overlay.active .dialog {
        transform: translateY(0);
      }

      .dialog-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 15px;
      }

      .dialog-title {
        font-size: 18px;
        font-weight: 600;
      }

      .dialog-close {
        background: none;
        border: none;
        font-size: 20px;
        cursor: pointer;
        color: #888;
      }

      .dialog-body {
        margin-bottom: 20px;
      }

      .dialog-input {
        width: 100%;
        padding: 8px 12px;
        border: 1px solid var(--border-color);
        border-radius: 4px;
        font-size: 14px;
        margin-bottom: 10px;
      }

      .dialog-footer {
        display: flex;
        justify-content: flex-end;
        gap: 10px;
      }

      .btn-cancel {
        background-color: #f5f5f5;
        color: var(--text-color);
      }

      .btn-cancel:hover {
        background-color: #e9e9e9;
      }

      .btn-confirm {
        background-color: var(--primary-color);
      }

      /* Toast notification styles */
      .toast-container {
        position: fixed;
        bottom: 20px;
        right: 20px;
        z-index: 1010;
      }

      .toast {
        background-color: white;
        border-radius: 4px;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        margin-top: 10px;
        padding: 12px 20px;
        display: flex;
        align-items: center;
        min-width: 250px;
        transform: translateX(100%);
        opacity: 0;
        transition: transform 0.3s, opacity 0.3s;
      }

      .toast.show {
        transform: translateX(0);
        opacity: 1;
      }

      .toast.success {
        border-left: 4px solid var(--success-color);
      }

      .toast.error {
        border-left: 4px solid var(--danger-color);
      }

      .toast.info {
        border-left: 4px solid var(--info-color);
      }

      .toast.warning {
        border-left: 4px solid var(--warning-color);
      }

      /* Upload progress styles */
      .upload-progress-container {
        position: fixed;
        bottom: 20px;
        left: 20px;
        z-index: 1010;
        width: 300px;
      }

      .progress-filename {
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
        max-width: 200px;
      }

      .upload-progress {
        background-color: var(--dialog-bg);
        color: var(--text-color);
        border-radius: 4px;
        box-shadow: 0 4px 12px var(--dialog-shadow);
        margin-top: 10px;
        padding: 12px 20px;
      }

      .upload-progress h4 {
        margin-bottom: 8px;
        font-size: 14px;
        display: flex;
        justify-content: space-between;
      }

      .progress-bar-container {
        width: 100%;
        height: 8px;
        background-color: var(--border-color);
        border-radius: 4px;
        overflow: hidden;
      }

      .progress-bar {
        height: 100%;
        background-color: var(--primary-color);
        border-radius: 4px;
        width: 0;
        transition: width 0.3s;
      }

      /* Editor styles */
      .editor-container {
        width: 100%;
        height: 400px;
        border: 1px solid var(--border-color);
        border-radius: 4px;
      }

      .editor-textarea {
        width: 100%;
        height: 100%;
        border: none;
        padding: 10px;
        font-family: monospace;
        font-size: 14px;
        resize: none;
        background-color: var(--editor-bg);
        color: var(--editor-text);
      }

      /* Dark mode specific styles */
      .dialog {
        background-color: var(--dialog-bg);
      }

      .file-table th {
        background-color: var(--table-header-bg);
        border-color: var(--border-color);
        color: var(--text-color);
        padding: 10px;
        font-weight: 600;
      }

      /* Add subtle header styling for dark mode */
      [data-theme="dark"] .file-table th {
        background-color: #333;
        border-bottom: 2px solid #444;
      }

      .file-table td {
        border-color: var(--border-color);
        background-color: var(--table-row-bg);
        padding: 8px;
      }

      /* Ensure alternating row colors for better readability */
      .file-table tr:nth-child(even) td {
        background-color: var(--row-hover-bg);
      }

      .file-table tr:hover td {
        background-color: var(--row-hover-bg);
      }

      /* Parent directory button styling */
      .parent-dir {
        background-color: var(--parent-dir-bg);
        color: var(--parent-dir-color);
        border: 1px solid var(--parent-dir-border);
        padding: 5px 10px;
        border-radius: 4px;
        display: inline-flex;
        align-items: center;
        gap: 5px;
        text-decoration: none;
        transition: background-color 0.2s;
      }

      .parent-dir:hover {
        background-color: var(--parent-dir-hover);
      }

      /* Drag and drop styles */
      .drag-drop-zone {
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        z-index: -1;
      }

      .drag-drop-overlay {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background-color: rgba(var(--primary-color-rgb), 0.1);
        border: 2px dashed var(--primary-color);
        border-radius: 4px;
        display: none;
        justify-content: center;
        align-items: center;
        z-index: 100;
      }

      .drag-drop-overlay.active {
        display: flex;
      }

      .drag-drop-message {
        background-color: var(--bg-color);
        padding: 20px;
        border-radius: 4px;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        text-align: center;
      }

      .toolbar,
      .action-bar {
        background-color: var(--toolbar-bg);
        border-color: var(--border-color);
      }

      .control-panel {
        background-color: var(--control-panel-bg);
        border: 1px solid var(--border-color);
        border-radius: 4px;
        padding: 10px;
        margin-bottom: 15px;
      }

      .dialog-input,
      input[type="text"],
      input[type="number"],
      select {
        background-color: var(--input-bg);
        color: var(--text-color);
        border-color: var(--border-color);
        border-radius: 4px;
      }

      .btn {
        background-color: var(--button-bg);
        color: var(--button-color);
        border-color: var(--button-border);
        transition: background-color 0.2s, border-color 0.2s;
      }

      .btn:hover {
        background-color: var(--button-hover-bg);
      }

      .btn:disabled {
        cursor: not-allowed;
        color: rgba(var(--button-color-rgb), 0.5);
      }

      .btn:disabled:hover {
        background-color: var(--button-bg);
      }

      .btn-primary {
        background-color: var(--primary-color);
        color: white;
      }

      .btn-primary:hover {
        background-color: var(--hover-color);
      }

      /* Fix for the checkbox styling in dark mode */
      input[type="checkbox"] {
        filter: invert(var(--checkbox-invert));
        accent-color: var(--primary-color);
      }

      /* Dialog styling updates */
      .dialog {
        box-shadow: 0 4px 10px var(--dialog-shadow);
      }

      /* Toast styling */
      .toast {
        background-color: var(--toast-bg);
        color: var(--text-color);
        border-color: var(--border-color);
        box-shadow: 0 4px 10px var(--dialog-shadow);
      }

      /* Filter input styling */
      .filter-container {
        background-color: var(--filter-bg);
        border-color: var(--filter-border);
      }

      .filter-input {
        background-color: var(--input-bg);
        color: var(--text-color);
      }

      /* Dark mode toggle button */
      .theme-switch {
        position: relative;
        display: inline-block;
        width: 40px;
        height: 24px;
        margin-left: 10px;
      }

      .theme-switch input {
        opacity: 0;
        width: 0;
        height: 0;
      }

      .slider {
        position: absolute;
        cursor: pointer;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background-color: #ccc;
        transition: 0.4s;
        border-radius: 34px;
      }

      .slider:before {
        position: absolute;
        content: "";
        height: 16px;
        width: 16px;
        left: 4px;
        bottom: 4px;
        background-color: white;
        transition: 0.4s;
        border-radius: 50%;
      }

      input:checked + .slider {
        background-color: #444;
      }

      input:checked + .slider:before {
        transform: translateX(16px);
        background-color: var(--bg-color);
      }

      body.view-only #btn-new-file,
      body.view-only #btn-new-directory,
      body.view-only #btn-upload,
      body.view-only #btn-move,
      body.view-only #btn-copy,
      body.view-only #btn-delete,
      body.view-only #btn-edit {
        display: none;
      }
    </style>
  </head>
  <body>
    <div class="drag-drop-zone"></div>

    <div class="container">
      <header>
        <h1>WebDir</h1>
        <div style="display: flex; align-items: center">
          <label class="theme-switch">
            <input type="checkbox" id="theme-toggle" />
            <span class="slider"></span>
          </label>
        </div>
      </header>

      <!-- Breadcrumb navigation -->
      <div class="control-container">
        <nav class="breadcrumb">
          <ol id="breadcrumb">
            <li><a href="/">Home</a></li>
            <!-- Dynamic breadcrumb items will be added here -->
          </ol>
        </nav>

        <!-- Control bar -->
        <div class="control-bar">
          <button
            type="button"
            id="btn-parent"
            class="btn btn-parent"
            aria-label="Parent Directory"
          >
            <svg
              xmlns="http://www.w3.org/2000/svg"
              viewBox="0 0 24 24"
              width="24"
              height="24"
              fill="none"
              stroke="currentColor"
              stroke-width="2"
              stroke-linecap="round"
              stroke-linejoin="round"
            >
              <path d="M15 18l-6-6 6-6" />
            </svg>
          </button>

          <div class="filter-container">
            <svg
              xmlns="http://www.w3.org/2000/svg"
              viewBox="0 0 24 24"
              width="24"
              height="24"
              fill="none"
              stroke="currentColor"
              stroke-width="2"
              stroke-linecap="round"
              stroke-linejoin="round"
            >
              <circle cx="11" cy="11" r="8" />
              <line x1="21" y1="21" x2="16.65" y2="16.65" />
            </svg>
            <input
              type="text"
              id="filter-input"
              class="filter-input"
              placeholder="RegExp name filter..."
              autocomplete="off"
              autofocus
            />
          </div>

          <button type="button" id="btn-new-file" class="btn">
            <svg
              xmlns="http://www.w3.org/2000/svg"
              viewBox="0 0 24 24"
              width="24"
              height="24"
              fill="none"
              stroke="currentColor"
              stroke-width="2"
              stroke-linecap="round"
              stroke-linejoin="round"
            >
              <path
                d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"
              />
              <polyline points="14 2 14 8 20 8" />
              <line x1="12" y1="18" x2="12" y2="12" />
              <line x1="9" y1="15" x2="15" y2="15" />
            </svg>
            File
          </button>

          <button type="button" id="btn-new-directory" class="btn">
            <svg
              xmlns="http://www.w3.org/2000/svg"
              viewBox="0 0 24 24"
              width="24"
              height="24"
              fill="none"
              stroke="currentColor"
              stroke-width="2"
              stroke-linecap="round"
              stroke-linejoin="round"
            >
              <path
                d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"
              />
              <line x1="12" y1="11" x2="12" y2="17" />
              <line x1="9" y1="14" x2="15" y2="14" />
            </svg>
            Directory
          </button>

          <button type="button" id="btn-upload" class="btn">
            <svg
              xmlns="http://www.w3.org/2000/svg"
              viewBox="0 0 24 24"
              width="24"
              height="24"
              fill="none"
              stroke="currentColor"
              stroke-width="2"
              stroke-linecap="round"
              stroke-linejoin="round"
            >
              <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4" />
              <polyline points="17 8 12 3 7 8" />
              <line x1="12" y1="3" x2="12" y2="15" />
            </svg>
            Upload
          </button>

          <button type="button" id="btn-move" class="btn" disabled>
            <svg
              xmlns="http://www.w3.org/2000/svg"
              viewBox="0 0 24 24"
              width="24"
              height="24"
              fill="none"
              stroke="currentColor"
              stroke-width="2"
              stroke-linecap="round"
              stroke-linejoin="round"
            >
              <path d="M5 9l-3 3 3 3" />
              <path d="M9 5l3-3 3 3" />
              <path d="M19 9l3 3-3 3" />
              <path d="M9 19l3 3 3-3" />
              <path d="M21 12H3" />
              <path d="M12 3v18" />
            </svg>
            Move
          </button>

          <button type="button" id="btn-copy" class="btn" disabled>
            <svg
              xmlns="http://www.w3.org/2000/svg"
              viewBox="0 0 24 24"
              width="24"
              height="24"
              fill="none"
              stroke="currentColor"
              stroke-width="2"
              stroke-linecap="round"
              stroke-linejoin="round"
            >
              <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
              <path
                d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"
              ></path>
            </svg>
            Copy
          </button>

          <button type="button" id="btn-delete" class="btn" disabled>
            <svg
              xmlns="http://www.w3.org/2000/svg"
              viewBox="0 0 24 24"
              width="24"
              height="24"
              fill="none"
              stroke="currentColor"
              stroke-width="2"
              stroke-linecap="round"
              stroke-linejoin="round"
            >
              <polyline points="3 6 5 6 21 6" />
              <path
                d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"
              />
              <line x1="10" y1="11" x2="10" y2="17" />
              <line x1="14" y1="11" x2="14" y2="17" />
            </svg>
            Delete
          </button>

          <button type="button" id="btn-edit" class="btn" disabled>
            <svg
              xmlns="http://www.w3.org/2000/svg"
              viewBox="0 0 24 24"
              width="24"
              height="24"
              fill="none"
              stroke="currentColor"
              stroke-width="2"
              stroke-linecap="round"
              stroke-linejoin="round"
            >
              <path
                d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"
              />
              <path
                d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"
              />
            </svg>
            Edit
          </button>

          <div class="selection-badge">
            <span id="selection-count">0</span>/<span id="total-count">0</span>
            selected
          </div>
        </div>
      </div>

      <!-- File table -->
      <div class="file-table-container">
        <table class="file-table">
          <thead>
            <tr>
              <th width="30">
                <input type="checkbox" id="select-all" class="checkbox" />
              </th>
              <th data-sort="name">Name</th>
              <th data-sort="size">Size</th>
              <th data-sort="permission">Permissions</th>
              <th data-sort="modTime">Modified</th>
            </tr>
          </thead>
          <tbody id="file-list">
            <!-- File list will be dynamically generated here -->
          </tbody>
        </table>
      </div>
    </div>

    <!-- New File Dialog -->
    <div id="new-file-dialog" class="dialog-overlay">
      <div class="dialog">
        <div class="dialog-header">
          <h3 class="dialog-title">Create New File</h3>
          <button type="button" class="dialog-close">&times;</button>
        </div>
        <div class="dialog-body">
          <input
            type="text"
            id="new-file-name"
            class="dialog-input"
            placeholder="Enter file name"
            autocomplete="off"
          />
        </div>
        <div class="dialog-footer">
          <button type="button" class="btn btn-cancel">Cancel</button>
          <button type="button" class="btn btn-confirm btn-primary">
            Create
          </button>
        </div>
      </div>
    </div>

    <!-- New Directory Dialog -->
    <div id="new-directory-dialog" class="dialog-overlay">
      <div class="dialog">
        <div class="dialog-header">
          <h3 class="dialog-title">Create New Directory</h3>
          <button type="button" class="dialog-close">&times;</button>
        </div>
        <div class="dialog-body">
          <input
            type="text"
            id="new-directory-name"
            class="dialog-input"
            placeholder="Directory name"
            autocomplete="off"
          />
          <p>Directory name can include '/' for multiple levels (mkdir -p)</p>
        </div>
        <div class="dialog-footer">
          <button type="button" class="btn btn-cancel">Cancel</button>
          <button type="button" class="btn btn-confirm btn-primary">
            Create
          </button>
        </div>
      </div>
    </div>

    <!-- Move Dialog -->
    <div id="move-dialog" class="dialog-overlay">
      <div class="dialog">
        <div class="dialog-header">
          <h3 class="dialog-title">Move</h3>
          <button type="button" class="dialog-close">&times;</button>
        </div>
        <div class="dialog-body">
          <input
            type="text"
            id="move-target"
            class="dialog-input"
            placeholder="Target path"
            autocomplete="off"
          />
        </div>
        <div class="dialog-footer">
          <button type="button" class="btn btn-cancel">Cancel</button>
          <button type="button" class="btn btn-confirm btn-primary">
            Move
          </button>
        </div>
      </div>
    </div>

    <!-- Copy Dialog -->
    <div id="copy-dialog" class="dialog-overlay">
      <div class="dialog">
        <div class="dialog-header">
          <h3 class="dialog-title">Copy</h3>
          <button type="button" class="dialog-close">&times;</button>
        </div>
        <div class="dialog-body">
          <input
            type="text"
            id="copy-target"
            class="dialog-input"
            placeholder="Target path"
            autocomplete="off"
          />
        </div>
        <div class="dialog-footer">
          <button type="button" class="btn btn-cancel">Cancel</button>
          <button type="button" class="btn btn-confirm btn-primary">
            Copy
          </button>
        </div>
      </div>
    </div>

    <!-- Editor Dialog -->
    <div id="editor-dialog" class="dialog-overlay">
      <div class="dialog" style="max-width: 800px; width: 80%">
        <div class="dialog-header">
          <h3 class="dialog-title">Edit File</h3>
          <button type="button" class="dialog-close">&times;</button>
        </div>
        <div class="dialog-body">
          <!-- Indentation Settings -->
          <div
            class="editor-settings"
            style="
              display: flex;
              align-items: center;
              margin-bottom: 8px;
              gap: 10px;
            "
          >
            <label style="display: flex; align-items: center; gap: 5px">
              <span>Indentation:</span>
              <select
                aria-label="Indentation"
                id="editor-indent-type"
                style="padding: 4px"
              >
                <option value="tab">Tabs</option>
                <option value="space">Spaces</option>
              </select>
            </label>
            <div
              id="editor-spaces-container"
              style="display: none; align-items: center; gap: 5px"
            >
              <label for="editor-spaces-count">Spaces:</label>
              <input
                type="number"
                id="editor-spaces-count"
                min="2"
                max="8"
                value="4"
                style="width: 50px; padding: 4px"
              />
            </div>
          </div>
          <div class="editor-container">
            <textarea id="editor-textarea" class="editor-textarea"></textarea>
          </div>
        </div>
        <div class="dialog-footer">
          <button type="button" class="btn btn-cancel">Cancel</button>
          <button type="button" class="btn btn-confirm btn-primary">
            Save
          </button>
        </div>
      </div>
    </div>

    <!-- Delete Confirmation Dialog -->
    <div id="delete-dialog" class="dialog-overlay">
      <div class="dialog">
        <div class="dialog-header">
          <h3 class="dialog-title">Confirm Delete</h3>
          <button type="button" class="dialog-close">&times;</button>
        </div>
        <div class="dialog-body">
          <p>Are you sure you want to delete the selected item(s)?</p>
          <p id="delete-count"></p>
        </div>
        <div class="dialog-footer">
          <button type="button" class="btn btn-cancel">Cancel</button>
          <button type="button" class="btn btn-confirm btn-primary">
            Delete
          </button>
        </div>
      </div>
    </div>

    <!-- Toast container for notifications -->
    <div class="toast-container" id="toast-container">
      <!-- Toasts will be dynamically added here -->
    </div>

    <!-- Upload progress container -->
    <div class="upload-progress-container" id="upload-progress-container">
      <!-- Upload progress bars will be dynamically added here -->
    </div>

    <!-- File input for uploads (hidden) -->
    <input type="file" id="upload-input" style="display: none" multiple />

    <!-- Drag and drop overlay -->
    <div class="drag-drop-overlay" id="drag-drop-overlay">
      <div class="drag-drop-message">
        <h3>Drop files to upload</h3>
        <p>Files will be uploaded to the current directory</p>
      </div>
    </div>

    <script>
      // Theme switching functionality
      function setTheme(isDark) {
        if (isDark) {
          document.documentElement.setAttribute("data-theme", "dark");
          localStorage.setItem("webdir-theme", "dark");
        } else {
          document.documentElement.removeAttribute("data-theme");
          localStorage.setItem("webdir-theme", "light");
        }
      }

      // Initialize theme from localStorage, defaulting to dark mode
      const savedTheme = localStorage.getItem("webdir-theme");
      // Always default to dark mode if no preference is saved
      const defaultDark = savedTheme !== "light";

      // Set initial theme state before page loads
      setTheme(defaultDark);

      document.addEventListener("DOMContentLoaded", () => {
        // Set initial toggle state
        const themeToggle = document.getElementById("theme-toggle");
        themeToggle.checked = defaultDark;

        // Add theme toggle event listener
        themeToggle.addEventListener("change", (e) => {
          setTheme(e.target.checked);
          document.activeElement.blur();
        });

        // Global state
        const state = {
          currentPath: "/",
          entries: [],
          selected: new Set(),
          sortField: "name",
          sortDirection: "asc",
          originalOrder: [],
        };

        // SVG Icons
        const icons = {
          directory:
            '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24" height="24" fill="#f1c40f" stroke="currentColor" stroke-width="1" stroke-linecap="round" stroke-linejoin="round"><path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"></path></svg>',
          file: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24" height="24" fill="#95a5a6" stroke="currentColor" stroke-width="1" stroke-linecap="round" stroke-linejoin="round"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path><polyline points="14 2 14 8 20 8"></polyline></svg>',
          unknown:
            '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24" height="24" fill="#bdc3c7" stroke="currentColor" stroke-width="1" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"></circle><path d="M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3"></path><line x1="12" y1="17" x2="12.01" y2="17"></line></svg>',
        };

        // DOM Elements
        const elements = {
          breadcrumb: document.getElementById("breadcrumb"),
          fileList: document.getElementById("file-list"),
          filterInput: document.getElementById("filter-input"),
          selectAll: document.getElementById("select-all"),
          selectionCount: document.getElementById("selection-count"),
          totalCount: document.getElementById("total-count"),
          btnParent: document.getElementById("btn-parent"),
          btnNewFile: document.getElementById("btn-new-file"),
          btnNewDirectory: document.getElementById("btn-new-directory"),
          btnUpload: document.getElementById("btn-upload"),
          btnMove: document.getElementById("btn-move"),
          btnCopy: document.getElementById("btn-copy"),
          btnDelete: document.getElementById("btn-delete"),
          btnEdit: document.getElementById("btn-edit"),
          uploadInput: document.getElementById("upload-input"),
          dragDropZone: document.body,
          dragDropOverlay: document.getElementById("drag-drop-overlay"),

          // Dialogs
          newDirectoryDialog: document.getElementById("new-directory-dialog"),
          newFileDialog: document.getElementById("new-file-dialog"),
          moveDialog: document.getElementById("move-dialog"),
          copyDialog: document.getElementById("copy-dialog"),
          editorDialog: document.getElementById("editor-dialog"),
          deleteDialog: document.getElementById("delete-dialog"),

          // Dialog inputs
          newDirectoryName: document.getElementById("new-directory-name"),
          moveTarget: document.getElementById("move-target"),
          copyTarget: document.getElementById("copy-target"),
          editorTextarea: document.getElementById("editor-textarea"),
          deleteCount: document.getElementById("delete-count"),

          // Containers
          toastContainer: document.getElementById("toast-container"),
          uploadProgressContainer: document.getElementById(
            "upload-progress-container"
          ),
        };

        // API functions
        const api = {
          // List directory contents
          async listDirectory(path) {
            try {
              const response = await fetch(
                `/?api=list&path=${encodeURIComponent(path)}`
              );
              if (!response.ok) {
                throw new Error(`HTTP error ${response.status}`);
              }
              const data = await response.json();
              if (!data.success) {
                throw new Error(data.message || "Unknown error");
              }
              return data.data;
            } catch (error) {
              showToast("error", `Failed to list directory: ${error.message}`);
              throw error;
            }
          },

          // Create file
          async createFile(path) {
            try {
              const response = await fetch("/?api=edit", {
                method: "POST",
                headers: {
                  "Content-Type": "application/json",
                },
                body: JSON.stringify({
                  path,
                  content: "",
                }),
              });

              if (!response.ok) {
                throw new Error(`HTTP error ${response.status}`);
              }

              const data = await response.json();
              if (!data.success) {
                throw new Error(data.message || "Unknown error");
              }

              showToast("success", "File created successfully");
              return data;
            } catch (error) {
              showToast("error", `Failed to create file: ${error.message}`);
              throw error;
            }
          },

          // Create directory
          async createDirectory(path) {
            try {
              const response = await fetch("/?api=mkdir", {
                method: "POST",
                headers: {
                  "Content-Type": "application/json",
                },
                body: JSON.stringify({ path }),
              });

              if (!response.ok) {
                throw new Error(`HTTP error ${response.status}`);
              }

              const data = await response.json();
              if (!data.success) {
                throw new Error(data.message || "Unknown error");
              }

              showToast("success", "Directory created successfully");
              return data;
            } catch (error) {
              showToast(
                "error",
                `Failed to create directory: ${error.message}`
              );
              throw error;
            }
          },

          // Upload files
          async uploadFiles(path, files, onProgress) {
            try {
              const formData = new FormData();

              // Add path to form data
              formData.append("path", path);

              // Add files to form data
              for (const file of files) {
                formData.append("file", file);
              }

              // Create XMLHttpRequest for progress tracking
              const xhr = new XMLHttpRequest();

              // Create promise to handle async upload
              const uploadPromise = new Promise((resolve, reject) => {
                xhr.open(
                  "POST",
                  `/?api=upload&path=${encodeURIComponent(path)}`
                );

                xhr.upload.addEventListener("progress", (event) => {
                  if (event.lengthComputable) {
                    const percentComplete = (event.loaded / event.total) * 100;
                    if (onProgress) {
                      onProgress(percentComplete);
                    }
                  }
                });

                xhr.onload = function () {
                  try {
                    const data = JSON.parse(xhr.responseText);
                    if (!data.success) {
                      reject(new Error(data.message || "Upload failed"));
                    } else {
                      resolve(data);
                    }
                  } catch (e) {
                    reject(new Error("Invalid response from server"));
                  }
                };

                xhr.onerror = function () {
                  reject(new Error("Network error"));
                };

                xhr.send(formData);
              });

              const result = await uploadPromise;
              showToast(
                "success",
                `Successfully uploaded ${result.data.count} file(s)`
              );
              return result;
            } catch (error) {
              showToast("error", `Upload failed: ${error.message}`);
              throw error;
            }
          },

          // Upload a single file with curl-compatible API
          async uploadCurlFile(path, file) {
            try {
              const formData = new FormData();
              formData.append("file", file);

              const response = await fetch(path, {
                method: "POST",
                body: formData,
              });

              if (!response.ok) {
                throw new Error(`HTTP error ${response.status}`);
              }

              showToast("success", "File uploaded successfully");
              return true;
            } catch (error) {
              showToast("error", `Upload failed: ${error.message}`);
              throw error;
            }
          },

          // Move files/directories
          async moveItems(paths, target) {
            try {
              const response = await fetch("/?api=move", {
                method: "POST",
                headers: {
                  "Content-Type": "application/json",
                },
                body: JSON.stringify({
                  paths,
                  target,
                }),
              });

              if (!response.ok) {
                throw new Error(`HTTP error ${response.status}`);
              }

              const data = await response.json();
              if (!data.success) {
                throw new Error(data.message || "Unknown error");
              }

              showToast(
                "success",
                `Successfully moved ${data.data.moved} item(s)`
              );
              return data;
            } catch (error) {
              showToast("error", `Failed to move items: ${error.message}`);
              throw error;
            }
          },

          // Copy files/directories
          async copyItems(paths, target) {
            try {
              const response = await fetch("/?api=copy", {
                method: "POST",
                headers: {
                  "Content-Type": "application/json",
                },
                body: JSON.stringify({
                  paths,
                  target,
                }),
              });

              if (!response.ok) {
                throw new Error(`HTTP error ${response.status}`);
              }

              const data = await response.json();
              if (!data.success) {
                throw new Error(data.message || "Unknown error");
              }

              showToast(
                "success",
                `Successfully copied ${data.data.copied} item(s)`
              );
              return data;
            } catch (error) {
              showToast("error", `Failed to copy items: ${error.message}`);
              throw error;
            }
          },

          // Delete files/directories
          async deleteItems(paths) {
            try {
              const response = await fetch("/?api=delete", {
                method: "POST",
                headers: {
                  "Content-Type": "application/json",
                },
                body: JSON.stringify({ paths }),
              });

              if (!response.ok) {
                throw new Error(`HTTP error ${response.status}`);
              }

              const data = await response.json();
              if (!data.success) {
                throw new Error(data.message || "Unknown error");
              }

              showToast(
                "success",
                `Successfully deleted ${data.data.deleted} item(s)`
              );
              return data;
            } catch (error) {
              showToast("error", `Failed to delete items: ${error.message}`);
              throw error;
            }
          },

          // Get file content for editing
          async getFileContent(path) {
            try {
              const response = await fetch(
                `/?api=edit&path=${encodeURIComponent(path)}`
              );
              if (!response.ok) {
                throw new Error(`HTTP error ${response.status}`);
              }

              const data = await response.json();
              if (!data.success) {
                throw new Error(data.message || "Unknown error");
              }

              return data.data;
            } catch (error) {
              showToast(
                "error",
                `Failed to get file content: ${error.message}`
              );
              throw error;
            }
          },

          // Save file content
          async saveFileContent(path, content) {
            try {
              const response = await fetch("/?api=edit", {
                method: "POST",
                headers: {
                  "Content-Type": "application/json",
                },
                body: JSON.stringify({
                  path,
                  content,
                }),
              });

              if (!response.ok) {
                throw new Error(`HTTP error ${response.status}`);
              }

              const data = await response.json();
              if (!data.success) {
                throw new Error(data.message || "Unknown error");
              }

              showToast("success", "File saved successfully");
              return data;
            } catch (error) {
              showToast("error", `Failed to save file: ${error.message}`);
              throw error;
            }
          },
        };

        // Utility functions

        // Format date for display
        function formatDate(dateString) {
          const date = new Date(dateString);

          // Format as YYYY-MM-DD HH:MM:SS
          const year = date.getFullYear();
          const month = String(date.getMonth() + 1).padStart(2, "0");
          const day = String(date.getDate()).padStart(2, "0");
          const hours = String(date.getHours()).padStart(2, "0");
          const minutes = String(date.getMinutes()).padStart(2, "0");
          const seconds = String(date.getSeconds()).padStart(2, "0");

          return `${year}-${month}-${day} ${hours}:${minutes}:${seconds}`;
        }

        // Show toast notification
        function showToast(type, message) {
          const toast = document.createElement("div");
          toast.className = `toast ${type}`;
          toast.textContent = message;

          elements.toastContainer.appendChild(toast);

          // Trigger reflow to enable transition
          toast.offsetHeight;

          // Show toast
          toast.classList.add("show");

          // Auto-hide after 3 seconds
          setTimeout(() => {
            toast.classList.remove("show");
            setTimeout(() => {
              toast.remove();
            }, 300); // Match transition time
          }, 3000);
        }

        // Create upload progress element
        function createUploadProgress(filename) {
          const progressElement = document.createElement("div");
          progressElement.className = "upload-progress";
          progressElement.innerHTML = `
            <h4>
                <span class="progress-filename">${filename}</span>
                <span class="progress-percent">0%</span>
            </h4>
            <div class="progress-bar-container">
                <div class="progress-bar" style="width: 0%"></div>
            </div>
        `;

          elements.uploadProgressContainer.appendChild(progressElement);

          return {
            update: (percent) => {
              const bar = progressElement.querySelector(".progress-bar");
              const percentText =
                progressElement.querySelector(".progress-percent");

              bar.style.width = `${percent}%`;
              percentText.textContent = `${Math.round(percent)}%`;
            },
            complete: () => {
              progressElement.querySelector(".progress-percent").textContent =
                "Done";
              setTimeout(() => {
                progressElement.remove();
              }, 2000);
            },
            error: () => {
              progressElement.style.borderLeft =
                "4px solid var(--danger-color)";
              progressElement.querySelector(".progress-percent").textContent =
                "Failed";
              setTimeout(() => {
                progressElement.remove();
              }, 3000);
            },
          };
        }

        // Show dialog
        function showDialog(dialog, onConfirm) {
          dialog.classList.add("active");

          const closeBtn = dialog.querySelector(".dialog-close");
          const cancelBtn = dialog.querySelector(".btn-cancel");
          const confirmBtn = dialog.querySelector(".btn-confirm");

          // Focus the first input if present
          const input = dialog.querySelector("input, textarea");
          if (input) {
            setTimeout(() => input.focus(), 100);
          }

          const closeDialog = () => {
            dialog.classList.remove("active");
            closeBtn.removeEventListener("click", closeDialog);
            cancelBtn.removeEventListener("click", closeDialog);
            confirmBtn.removeEventListener("click", handleConfirm);
          };

          const handleConfirm = () => {
            if (onConfirm()) {
              closeDialog();
            }
          };

          closeBtn.addEventListener("click", closeDialog);
          cancelBtn.addEventListener("click", closeDialog);
          confirmBtn.addEventListener("click", handleConfirm);

          // Close on Escape key
          const handleKeyDown = (e) => {
            if (e.key === "Escape") {
              e.preventDefault();
              closeDialog();
              return;
            }

            if (
              e.target.tagName === "TEXTAREA" ||
              dialog === elements.editorDialog
            ) {
              return;
            }

            // Only handle Enter for non-editor dialogs
            if (e.key === "Enter") {
              e.preventDefault();
              handleConfirm();
            }
          };

          document.addEventListener("keydown", handleKeyDown);

          // Remove event listener when dialog is closed
          dialog.addEventListener("transitionend", () => {
            if (!dialog.classList.contains("active")) {
              document.removeEventListener("keydown", handleKeyDown);
            }
          });
        }
        // Update UI based on state
        function updateUI() {
          // Update breadcrumb
          updateBreadcrumb();

          // Update file list
          updateFileList();

          // Update selection count
          updateSelectionCount();

          // Update button states
          updateButtonStates();

          // Update select all checkbox state
          updateSelectAllCheckbox();
        }

        // Update breadcrumb navigation
        function updateBreadcrumb() {
          // Clear existing items except Home
          while (elements.breadcrumb.children.length > 1) {
            elements.breadcrumb.removeChild(elements.breadcrumb.lastChild);
          }

          // Skip if we're at root or at dot path
          if (state.currentPath === "/" || state.currentPath === "/.") {
            return;
          }

          // Split path and create breadcrumb items
          const parts = state.currentPath.split("/").filter((p) => p);
          let currentPath = "";

          parts.forEach((part, index) => {
            currentPath += "/" + part;

            // Ensure the path ends with a slash for directories
            let targetPath = currentPath;
            if (!targetPath.endsWith("/")) {
              targetPath += "/";
            }

            const li = document.createElement("li");
            const a = document.createElement("a");
            a.textContent = part;
            a.href = targetPath;
            a.addEventListener("click", (e) => {
              e.preventDefault();
              // Explicitly call navigateTo with the right path
              navigateTo(targetPath);
            });

            li.appendChild(a);
            elements.breadcrumb.appendChild(li);
          });
        }

        // Update file list
        function updateFileList() {
          // Clear existing rows
          elements.fileList.innerHTML = "";

          // Apply current sort
          const sortedEntries = sortEntries([...state.entries]);

          // Create rows for each entry
          sortedEntries.forEach((entry) => {
            const row = document.createElement("tr");

            // Add click event to row to focus on checkbox (except when clicking on name)
            row.addEventListener("click", (e) => {
              // Check if click was on the name link
              const nameLink = row.querySelector(".filename a");
              const checkbox = row.querySelector('input[type="checkbox"]');

              // Don't focus on checkbox if clicking on name link
              if (e.target === nameLink || e.target === checkbox) {
                return;
              }

              // Find the checkbox and focus on it
              if (checkbox) {
                e.preventDefault();
                checkbox.focus();
              }
            });

            // Checkbox cell
            const checkboxCell = document.createElement("td");
            const checkbox = document.createElement("input");
            checkbox.type = "checkbox";
            checkbox.className = "checkbox";
            checkbox.checked = state.selected.has(entry.path);
            checkbox.name = "entry";
            checkbox.addEventListener("change", () => {
              if (checkbox.checked) {
                state.selected.add(entry.path);
              } else {
                state.selected.delete(entry.path);
              }
              updateSelectionCount();
              updateButtonStates();
            });

            // Add keydown event to checkbox to trigger entry link click when Enter is pressed
            // or when right arrow is pressed on a directory
            checkbox.addEventListener("keydown", (e) => {
              // Skip if any dialog is active
              const activeDialog = document.querySelector(
                ".dialog-overlay.active"
              );
              if (activeDialog) {
                return;
              }

              if (
                e.key === "Enter" ||
                (e.key === "ArrowRight" && entry.isDir)
              ) {
                e.preventDefault();
                // Find and click the entry link
                const nameLink = row.querySelector(".filename a");
                if (nameLink) {
                  nameLink.click();
                }
              }
            });
            checkboxCell.appendChild(checkbox);
            row.appendChild(checkboxCell);

            // Name cell with icon
            const nameCell = document.createElement("td");
            const nameContainer = document.createElement("div");
            nameContainer.className = "filename";

            // Icon based on type
            const iconSpan = document.createElement("span");
            iconSpan.innerHTML = entry.isDir ? icons.directory : icons.file;
            nameContainer.appendChild(iconSpan);

            // Name with link
            const nameLink = document.createElement("a");
            nameLink.textContent = entry.name;
            nameLink.title = entry.name;
            nameLink.href = entry.path;
            nameLink.addEventListener("click", (e) => {
              if (entry.isDir) {
                if (!e.metaKey && !e.ctrlKey) {
                  e.preventDefault();
                  navigateTo(entry.path);
                }
              } else {
                if (e.shiftKey) {
                  // Open in preview window
                  e.preventDefault();
                  const maxWidth = Math.min(800, window.innerWidth * 0.9);
                  const maxHeight = Math.min(500, window.innerHeight * 0.9);
                  const left = (window.screen.width - maxWidth) / 2;
                  const top = (window.screen.height - maxHeight) / 2;
                  window.open(
                    entry.path,
                    "webdirPreview",
                    `width=${maxWidth},height=${maxHeight},top=${top},left=${left},resizable=yes,scrollbars=yes`
                  );
                } else {
                  e.preventDefault();
                  window.open(entry.path, "_blank");
                }
              }
            });
            nameContainer.appendChild(nameLink);
            nameCell.appendChild(nameContainer);
            row.appendChild(nameCell);

            // Size cell
            const sizeCell = document.createElement("td");
            sizeCell.textContent = entry.isDir ? "-" : entry.humanSize;
            row.appendChild(sizeCell);

            // Permission cell
            const permissionCell = document.createElement("td");
            permissionCell.textContent = entry.permission;
            row.appendChild(permissionCell);

            // Modified date cell
            const modifiedCell = document.createElement("td");
            modifiedCell.textContent = formatDate(entry.modTime);
            row.appendChild(modifiedCell);

            // Add row to table
            elements.fileList.appendChild(row);
          });

          // Update sort indicators
          updateSortIndicators();
        }

        // Update sort indicators in table header
        function updateSortIndicators() {
          const headers = document.querySelectorAll(
            ".file-table th[data-sort]"
          );
          headers.forEach((header) => {
            header.classList.remove("sorted", "asc", "desc");
            if (header.dataset.sort === state.sortField) {
              header.classList.add("sorted");
              header.classList.add(state.sortDirection);
            }
          });
        }

        // Update selection count
        function updateSelectionCount() {
          elements.selectionCount.textContent = state.selected.size;
          elements.totalCount.textContent = state.entries.length;
        }

        // Update select all checkbox state based on visible entries
        function updateSelectAllCheckbox() {
          const visibleEntries = elements.fileList.querySelectorAll("tr");
          let checkedCount = 0;

          visibleEntries.forEach((row) => {
            const checkbox = row.querySelector('input[type="checkbox"]');
            if (checkbox && checkbox.checked) {
              checkedCount++;
            }
          });

          // Update select all checkbox
          if (visibleEntries.length === 0) {
            elements.selectAll.checked = false;
            elements.selectAll.indeterminate = false;
          } else if (checkedCount === 0) {
            elements.selectAll.checked = false;
            elements.selectAll.indeterminate = false;
          } else if (checkedCount === visibleEntries.length) {
            elements.selectAll.checked = true;
            elements.selectAll.indeterminate = false;
          } else {
            elements.selectAll.checked = false;
            elements.selectAll.indeterminate = true;
          }
        }

        // Update button states based on selection
        function updateButtonStates() {
          const selectedCount = state.selected.size;
          const hasSelection = selectedCount > 0;
          const hasSingleSelection = selectedCount === 1;
          const hasSingleFile =
            hasSingleSelection && getSelectedEntries()[0].isDir === false;

          // Enable/disable buttons based on selection
          elements.btnMove.disabled = !hasSelection;
          elements.btnCopy.disabled = !hasSelection;
          elements.btnDelete.disabled = !hasSelection;
          elements.btnEdit.disabled = !(hasSingleSelection && hasSingleFile);

          // New directory button should always be enabled
          // Empty directories are valid locations for new directories
          elements.btnNewDirectory.disabled = false;

          // Adjust upload button behavior based on selection
          if (hasSingleSelection) {
            const selected = getSelectedEntries()[0];
            elements.btnUpload.disabled = false;
            elements.uploadInput.multiple = selected.isDir;
          } else {
            elements.btnUpload.disabled = false;
            elements.uploadInput.multiple = true;
          }
        }

        // Sort entries based on current sort field and direction
        function sortEntries(entries) {
          // If no sort is applied, return in original order
          if (!state.sortField || state.sortDirection === "none") {
            return state.originalOrder.length
              ? entries.sort((a, b) => {
                  const indexA = state.originalOrder.findIndex(
                    (e) => e.path === a.path
                  );
                  const indexB = state.originalOrder.findIndex(
                    (e) => e.path === b.path
                  );
                  return indexA - indexB;
                })
              : entries;
          }

          return entries.sort((a, b) => {
            // Always sort directories first, then by the specified field
            if (a.isDir !== b.isDir) {
              return a.isDir ? -1 : 1;
            }

            let comparison = 0;

            // Compare based on sort field
            switch (state.sortField) {
              case "name":
                comparison = a.name.localeCompare(b.name);
                break;
              case "size":
                comparison = a.size - b.size;
                break;
              case "permission":
                comparison = a.permission.localeCompare(b.permission);
                break;
              case "createTime":
                comparison =
                  new Date(a.createTime || 0) - new Date(b.createTime || 0);
                break;
              case "modTime":
                comparison = new Date(a.modTime) - new Date(b.modTime);
                break;
              case "accessTime":
                comparison =
                  new Date(a.accessTime || 0) - new Date(b.accessTime || 0);
                break;
              default:
                comparison = 0;
            }

            // Apply sort direction
            return state.sortDirection === "asc" ? comparison : -comparison;
          });
        }

        // Get selected entries
        function getSelectedEntries() {
          return state.entries.filter((entry) =>
            state.selected.has(entry.path)
          );
        }

        // Navigate to a path
        async function navigateTo(path) {
          try {
            // Clear selection
            state.selected.clear();

            // Fetch directory contents
            const contents = await api.listDirectory(path);

            // Store previous path
            const previousPath = state.currentPath + "/";

            // Update state
            state.currentPath = contents.path;
            state.entries = contents.entries;
            state.originalOrder = [...contents.entries];

            // Update window title to show current path
            const pathName = contents.path === "/." ? "/" : contents.path;
            document.title = pathName;

            // Update URL without reloading the page
            history.pushState(null, "", path);

            // Update UI
            updateUI();

            // Clear filter
            elements.filterInput.value = "";

            // Disable parent button if we're at the root
            elements.btnParent.disabled = path === "/";

            // Focus on the checkbox of the entry that matches the previous path
            document
              .querySelector(
                `.file-table a[href="${CSS.escape(previousPath)}"]`
              )
              ?.closest(".file-table tr")
              ?.querySelector('input[type="checkbox"]')
              ?.focus();
          } catch (error) {
            console.error("Navigation error:", error);
          }
        }

        // Apply filter to entries
        function applyFilter(filterText) {
          if (!filterText) {
            // If filter is empty, show all entries
            updateFileList();
            return;
          }

          try {
            // Create RegExp from filter text
            const regex = new RegExp(filterText, "i");

            // Filter entries
            const filteredEntries = state.entries.filter((entry) =>
              regex.test(entry.name)
            );

            // Temporarily replace entries with filtered ones
            const originalEntries = state.entries;
            state.entries = filteredEntries;

            // Update file list
            updateFileList();

            // Restore original entries
            state.entries = originalEntries;

            // Update select all checkbox state based on filtered entries
            updateSelectAllCheckbox();
          } catch (error) {
            // Invalid regex, just use as string
            console.error("Filter error:", error);
            showToast("error", "Invalid filter pattern");
          }
        }

        // Event handlers

        // Handle parent directory button click
        elements.btnParent.addEventListener("click", () => {
          if (state.currentPath === "/") {
            return;
          }

          const parentPath = state.currentPath.substring(
            0,
            state.currentPath.lastIndexOf("/")
          );
          navigateTo(parentPath || "/");
        });

        // Handle new file button click
        elements.btnNewFile.addEventListener("click", () => {
          const input = document.getElementById("new-file-name");
          input.value = "";

          showDialog(elements.newFileDialog, () => {
            const fileName = input.value.trim();
            if (!fileName) {
              showToast("error", "File name cannot be empty");
              return false;
            }

            const selectedEntries = getSelectedEntries();
            let basePath = state.currentPath;

            // If a single directory is selected, create in that directory
            if (selectedEntries.length === 1 && selectedEntries[0].isDir) {
              basePath = selectedEntries[0].path;
            }

            // Create the file
            const path =
              basePath + (basePath.endsWith("/") ? "" : "/") + fileName;

            api
              .createFile(path)
              .then(() => {
                navigateTo(state.currentPath);
              })
              .catch((error) => {
                console.error("Create file error:", error);
              });

            return true;
          });
        });

        // Handle new directory button click
        elements.btnNewDirectory.addEventListener("click", () => {
          elements.newDirectoryName.value = "";

          showDialog(elements.newDirectoryDialog, () => {
            const directoryName = elements.newDirectoryName.value.trim();
            if (!directoryName) {
              showToast("error", "Directory name cannot be empty");
              return false;
            }

            const selectedEntries = getSelectedEntries();
            let basePath = state.currentPath;

            // If a single directory is selected, create in that directory
            if (selectedEntries.length === 1 && selectedEntries[0].isDir) {
              basePath = selectedEntries[0].path;
            }

            // Create the directory
            const path =
              basePath + (basePath.endsWith("/") ? "" : "/") + directoryName;

            api
              .createDirectory(path)
              .then(() => {
                navigateTo(state.currentPath);
              })
              .catch((error) => {
                console.error("Create directory error:", error);
              });

            return true;
          });
        });

        // Handle upload button click
        elements.btnUpload.addEventListener("click", () => {
          const selectedEntries = getSelectedEntries();

          if (selectedEntries.length === 1) {
            const selected = selectedEntries[0];
            elements.uploadInput.multiple = selected.isDir;
          } else {
            elements.uploadInput.multiple = true;
          }

          elements.uploadInput.click();
        });

        // Handle file selection for upload
        elements.uploadInput.addEventListener("change", () => {
          if (elements.uploadInput.files.length === 0) {
            return;
          }

          const files = elements.uploadInput.files;
          const selectedEntries = getSelectedEntries();
          let uploadPath = state.currentPath;

          // Determine upload destination
          if (selectedEntries.length === 1) {
            const selected = selectedEntries[0];
            if (selected.isDir) {
              // Upload to selected directory
              uploadPath = selected.path;
            } else if (files.length === 1) {
              // Replace selected file
              uploadPath = selected.path;
            }
          }

          // Create progress tracker
          const progressTracker = createUploadProgress(
            files.length === 1 ? files[0].name : `${files.length} files`
          );

          // Upload files
          api
            .uploadFiles(uploadPath, files, (progress) => {
              progressTracker.update(progress);
            })
            .then(() => {
              progressTracker.complete();

              // Clear file input
              elements.uploadInput.value = "";

              // Refresh directory listing
              navigateTo(state.currentPath);
            })
            .catch((error) => {
              progressTracker.error();
              console.error("Upload error:", error);

              // Clear file input
              elements.uploadInput.value = "";
            });
        });

        // Handle move button click
        elements.btnMove.addEventListener("click", () => {
          const selectedEntries = getSelectedEntries();
          if (selectedEntries.length === 0) {
            return;
          }

          let targetPath;
          if (selectedEntries.length === 1) {
            // For single item, default to the item's name for renaming
            const selected = selectedEntries[0];
            const name = selected.name.endsWith("/")
              ? selected.name.substring(0, selected.name.length - 1)
              : selected.name;

            // Handle path construction to avoid /./filename issues
            if (state.currentPath === "/" || state.currentPath === "/.") {
              // At root, just use the name
              targetPath = "/" + name;
            } else {
              // In a subdirectory
              targetPath =
                state.currentPath +
                (state.currentPath.endsWith("/") ? "" : "/") +
                name;
            }
          } else {
            // Multiple items selected, just use current path
            targetPath = state.currentPath;
          }

          elements.moveTarget.value = targetPath;

          showDialog(elements.moveDialog, () => {
            const target = elements.moveTarget.value.trim();
            if (!target) {
              showToast("error", "Target path cannot be empty");
              return false;
            }

            const paths = selectedEntries.map((entry) => entry.path);

            api
              .moveItems(paths, target)
              .then(() => {
                // Clear selection
                state.selected.clear();

                // Refresh directory listing
                navigateTo(state.currentPath);
              })
              .catch((error) => {
                console.error("Move error:", error);
              });

            return true;
          });
        });

        // Handle copy button click
        elements.btnCopy.addEventListener("click", () => {
          const selectedEntries = getSelectedEntries();
          if (selectedEntries.length === 0) {
            return;
          }

          // Show copy dialog
          const targetPath = state.currentPath + "/";
          elements.copyDialog.querySelector(".dialog-title").textContent =
            "Copy To";
          elements.copyTarget.value = targetPath;

          showDialog(elements.copyDialog, () => {
            const target = elements.copyTarget.value.trim();
            if (!target) {
              showToast("error", "Target path cannot be empty");
              return false;
            }

            const paths = selectedEntries.map((entry) => entry.path);

            api
              .copyItems(paths, target)
              .then(() => {
                // Refresh directory listing
                navigateTo(state.currentPath);
              })
              .catch((error) => {
                console.error("Copy error:", error);
              });

            return true;
          });

          // Reset dialog title after it's closed
          elements.copyDialog.addEventListener(
            "dialogclose",
            () => {
              elements.copyDialog.querySelector(".dialog-title").textContent =
                "Copy To";
            },
            { once: true }
          );
        });

        // Handle delete button click
        elements.btnDelete.addEventListener("click", () => {
          const selectedEntries = getSelectedEntries();
          if (selectedEntries.length === 0) {
            return;
          }

          // Update delete confirmation text
          elements.deleteCount.textContent = `${selectedEntries.length} item(s) will be permanently deleted.`;

          showDialog(elements.deleteDialog, () => {
            const paths = selectedEntries.map((entry) => entry.path);

            api
              .deleteItems(paths)
              .then(() => {
                // Clear selection
                state.selected.clear();

                // Refresh directory listing
                navigateTo(state.currentPath);
              })
              .catch((error) => {
                console.error("Delete error:", error);
              });

            return true;
          });
        });

        // Get additional editor elements
        const elements2 = {
          indentType: document.getElementById("editor-indent-type"),
          spacesContainer: document.getElementById("editor-spaces-container"),
          spacesCount: document.getElementById("editor-spaces-count"),
        };

        // Toggle space count visibility based on indent type
        elements2.indentType.addEventListener("change", () => {
          elements2.spacesContainer.style.display =
            elements2.indentType.value === "space" ? "flex" : "none";
        });

        // Add enhanced Tab, Shift+Tab and Enter support to the editor textarea
        elements.editorTextarea.addEventListener("keydown", (e) => {
          const start = e.target.selectionStart;
          const end = e.target.selectionEnd;
          const value = e.target.value;

          // Helper function to get current line indentation
          const getLineIndentation = (line) => {
            let indent = "";
            for (let i = 0; i < line.length; i++) {
              if (line[i] === "\t" || line[i] === " ") {
                indent += line[i];
              } else {
                break;
              }
            }
            return indent;
          };

          // Handle Tab key
          if (e.key === "Tab") {
            e.preventDefault(); // Prevent focus moving out of textarea

            // Get indentation settings
            const useSpaces = elements2.indentType.value === "space";
            const spacesCount = parseInt(elements2.spacesCount.value) || 4;
            const spacesIndent = " ".repeat(spacesCount);
            const indentChar = useSpaces ? spacesIndent : "\t";
            const indentSize = useSpaces ? spacesCount : 1;

            if (e.shiftKey) {
              // Shift+Tab: Remove one level of indentation at the beginning of the line
              const lineStart = value.lastIndexOf("\n", start - 1) + 1;
              const lineEnd = value.indexOf("\n", start);
              const currentLine =
                lineEnd >= 0
                  ? value.substring(lineStart, lineEnd)
                  : value.substring(lineStart);

              if (currentLine.startsWith("\t")) {
                // Remove a tab character
                e.target.value =
                  value.substring(0, lineStart) +
                  currentLine.substring(1) +
                  (lineEnd >= 0 ? value.substring(lineEnd) : "");
                e.target.selectionStart = e.target.selectionEnd = Math.max(
                  lineStart,
                  start - 1
                );
              } else if (currentLine.startsWith(" ")) {
                // For spaces, try to remove the configured number of spaces
                let spacesToRemove = 0;
                for (
                  let i = 0;
                  i < spacesCount &&
                  i < currentLine.length &&
                  currentLine[i] === " ";
                  i++
                ) {
                  spacesToRemove++;
                }

                if (spacesToRemove > 0) {
                  e.target.value =
                    value.substring(0, lineStart) +
                    currentLine.substring(spacesToRemove) +
                    (lineEnd >= 0 ? value.substring(lineEnd) : "");
                  e.target.selectionStart = e.target.selectionEnd = Math.max(
                    lineStart,
                    start - spacesToRemove
                  );
                }
              }
            } else {
              // Tab: Insert indentation
              e.target.value =
                value.substring(0, start) + indentChar + value.substring(end);
              e.target.selectionStart = e.target.selectionEnd =
                start + indentSize;
            }
          }

          // Handle Enter key to maintain indentation
          else if (e.key === "Enter") {
            const lineStart = value.lastIndexOf("\n", start - 1) + 1;
            const currentLine = value.substring(lineStart, start);
            const indentation = getLineIndentation(currentLine);

            if (indentation) {
              e.preventDefault();
              e.target.value =
                value.substring(0, start) +
                "\n" +
                indentation +
                value.substring(end);
              e.target.selectionStart = e.target.selectionEnd =
                start + 1 + indentation.length;
            }
          }
        });

        // Handle edit button click
        elements.btnEdit.addEventListener("click", () => {
          const selectedEntries = getSelectedEntries();
          if (selectedEntries.length !== 1 || selectedEntries[0].isDir) {
            return;
          }

          const filePath = selectedEntries[0].path;

          // Get file content
          api
            .getFileContent(filePath)
            .then((data) => {
              elements.editorTextarea.value = data.content;

              showDialog(elements.editorDialog, () => {
                const content = elements.editorTextarea.value;

                api
                  .saveFileContent(filePath, content)
                  .then(() => {
                    // Refresh directory listing
                    navigateTo(state.currentPath);
                  })
                  .catch((error) => {
                    console.error("Save error:", error);
                  });

                return true;
              });
            })
            .catch((error) => {
              console.error("Edit error:", error);
            });
        });

        // Handle select all checkbox
        elements.selectAll.addEventListener("change", () => {
          // Get all visible rows
          const visibleRows = Array.from(
            elements.fileList.querySelectorAll("tr")
          );

          if (elements.selectAll.checked) {
            // Select all visible entries (respecting filter)
            visibleRows.forEach((row) => {
              const checkbox = row.querySelector('input[type="checkbox"]');
              if (checkbox) {
                checkbox.checked = true;

                // Find the corresponding entry in state.entries
                const nameLink = row.querySelector("td:nth-child(2) a");
                if (nameLink) {
                  const entryName = nameLink.textContent;
                  const entry = state.entries.find((e) => e.name === entryName);
                  if (entry) {
                    state.selected.add(entry.path);
                  }
                }
              }
            });
          } else {
            // Deselect all visible entries
            visibleRows.forEach((row) => {
              const checkbox = row.querySelector('input[type="checkbox"]');
              if (checkbox) {
                checkbox.checked = false;

                // Find the corresponding entry in state.entries
                const nameLink = row.querySelector("td:nth-child(2) a");
                if (nameLink) {
                  const entryName = nameLink.textContent;
                  const entry = state.entries.find((e) => e.name === entryName);
                  if (entry) {
                    state.selected.delete(entry.path);
                  }
                }
              }
            });
          }

          updateUI();
          applyFilter(elements.filterInput.value.trim());
        });

        // Add keyboard navigation for select all checkbox
        elements.selectAll.addEventListener("keydown", (e) => {
          if (e.key === "ArrowDown") {
            e.preventDefault();
            focusOnNextElement(elements.selectAll);
          } else if (e.key === "ArrowUp") {
            e.preventDefault();
            focusOnPreviousElement(elements.selectAll);
          }
        });

        // Handle filter input
        elements.filterInput.addEventListener("input", () => {
          applyFilter(elements.filterInput.value.trim());
        });

        // Add keyboard navigation for filter input
        elements.filterInput.addEventListener("keydown", (e) => {
          if (e.key === "ArrowDown") {
            e.preventDefault();
            focusOnNextElement(elements.filterInput);
          } else if (e.key === "ArrowUp") {
            e.preventDefault();
            focusOnPreviousElement(elements.filterInput);
          }
        });

        // Handle sort column click
        document.querySelectorAll(".file-table th[data-sort]").forEach((th) => {
          th.addEventListener("click", () => {
            const field = th.dataset.sort;

            // Update sort state
            if (state.sortField === field) {
              // Cycle through sort directions: asc -> desc -> none
              if (state.sortDirection === "asc") {
                state.sortDirection = "desc";
              } else if (state.sortDirection === "desc") {
                state.sortDirection = "none";
                state.sortField = null;
              }
            } else {
              state.sortField = field;
              state.sortDirection = "asc";
            }

            // Update UI
            updateFileList();
          });
        });

        // Handle browser navigation (back/forward)
        window.addEventListener("popstate", () => {
          navigateTo(window.location.pathname);
        });

        // Initialize the application
        async function init() {
          try {
            // Get current path from URL
            const path = decodeURI(window.location.pathname);

            // Navigate to current path
            await navigateTo(path);
          } catch (error) {
            console.error("Initialization error:", error);
            showToast("error", `Failed to initialize: ${error.message}`);
          }
        }

        // Set up keyboard shortcuts
        setupKeyboardShortcuts();

        // Set up keyboard navigation for filter and checkboxes
        setupCheckboxNavigation();

        // Set up drag and drop functionality
        setupDragAndDrop();

        // Function to set up keyboard shortcuts
        function setupKeyboardShortcuts() {
          document.addEventListener("keydown", (e) => {
            // Skip if any dialog is active
            const activeDialog = document.querySelector(
              ".dialog-overlay.active"
            );
            if (activeDialog) {
              return;
            }

            // Handle arrow keys when no element is focused (document.activeElement is body)
            if (document.activeElement === document.body) {
              if (e.key === "ArrowDown") {
                e.preventDefault();
                // Focus on first entry checkbox
                const firstCheckbox = document.querySelector(
                  'tbody input[type="checkbox"]'
                );
                if (firstCheckbox) {
                  firstCheckbox.focus();
                  return;
                }
              } else if (e.key === "ArrowUp") {
                e.preventDefault();
                // Focus on last entry checkbox
                const checkboxes = document.querySelectorAll(
                  'tbody input[type="checkbox"]'
                );
                if (checkboxes.length > 0) {
                  checkboxes[checkboxes.length - 1].focus();
                  return;
                }
              }
            }

            // Press escape to defocus any focused element
            if (e.key === "Escape") {
              // Blur the active element to remove focus
              if (document.activeElement) {
                document.activeElement.blur();
              }
              return;
            }

            // Press left to go to the parent directory when not focusing on anything or when focusing on a checkbox in the file table
            if (
              e.key === "ArrowLeft" &&
              (document.activeElement === document.body ||
                (document.activeElement.tagName === "INPUT" &&
                  document.activeElement.type === "checkbox" &&
                  document.activeElement.closest(".file-table")))
            ) {
              e.preventDefault();
              elements.btnParent.click();
              return;
            }

            // Skip if we're in an input field (except file-table checkboxes) or textarea
            if (
              (e.target.tagName === "INPUT" &&
                !(
                  e.target.type === "checkbox" &&
                  e.target.closest(".file-table")
                )) ||
              e.target.tagName === "TEXTAREA"
            ) {
              return;
            }

            // Prevent default for arrow keys if not focused on an input field
            if (
              ["ArrowLeft", "ArrowRight", "ArrowUp", "ArrowDown"].includes(
                e.key
              )
            ) {
              e.preventDefault();
            }

            // Skip if modifier keys are pressed
            if (e.ctrlKey || e.metaKey || e.altKey) {
              return;
            }

            switch (e.key.toLowerCase()) {
              case "s":
                // Focus on filter input
                e.preventDefault();
                elements.filterInput.focus();
                break;

              case "delete":
              case "backspace":
                // Delete selected items
                if (state.selected.size > 0 && !elements.btnDelete.disabled) {
                  e.preventDefault();
                  elements.btnDelete.click();
                }
                break;

              case "f":
                // New file
                e.preventDefault();
                elements.btnNewFile.click();
                break;

              case "d":
                // New directory
                e.preventDefault();
                elements.btnNewDirectory.click();
                break;

              case "m":
                // Move
                if (state.selected.size > 0 && !elements.btnMove.disabled) {
                  e.preventDefault();
                  elements.btnMove.click();
                }
                break;

              case "c":
                // Copy
                if (state.selected.size > 0 && !elements.btnCopy.disabled) {
                  e.preventDefault();
                  elements.btnCopy.click();
                }
                break;

              case "e":
                // Edit file
                if (state.selected.size === 1 && !elements.btnEdit.disabled) {
                  e.preventDefault();
                  elements.btnEdit.click();
                }
                break;

              case "u":
                // Upload
                e.preventDefault();
                elements.btnUpload.click();
                break;

              case "a":
                // Select all / deselect all
                if (e.ctrlKey || e.metaKey) {
                  // Let the browser handle Ctrl+A/Cmd+A
                  return;
                }
                e.preventDefault();
                elements.selectAll.click();
                break;
            }
          });
        }

        // Function to set up drag and drop handlers
        function setupDragAndDrop() {
          const zone = elements.dragDropZone;
          const overlay = elements.dragDropOverlay;
          let dragCounter = 0;

          // Prevent default drag behaviors
          ["dragenter", "dragover", "dragleave", "drop"].forEach(
            (eventName) => {
              zone.addEventListener(eventName, preventDefaults, false);
            }
          );

          function preventDefaults(e) {
            e.preventDefault();
            e.stopPropagation();
          }

          // Handle drag enter
          zone.addEventListener(
            "dragenter",
            function (e) {
              dragCounter++;
              overlay.classList.add("active");
            },
            false
          );

          // Handle drag over
          zone.addEventListener(
            "dragover",
            function (e) {
              e.preventDefault();
            },
            false
          );

          // Handle drag leave
          zone.addEventListener(
            "dragleave",
            function (e) {
              dragCounter--;
              if (dragCounter === 0) {
                overlay.classList.remove("active");
              }
            },
            false
          );

          // Handle drop - this also resets the counter
          zone.addEventListener(
            "drop",
            function (e) {
              dragCounter = 0;
              overlay.classList.remove("active");
              handleDrop(e);
            },
            false
          );

          function handleDrop(e) {
            const dt = e.dataTransfer;
            const files = dt.files;

            if (files.length > 0) {
              handleFiles(files);
            }
          }

          // Handle the dropped files
          function handleFiles(files) {
            // Create progress tracker
            const progressTracker = createUploadProgress(
              files.length === 1 ? files[0].name : `${files.length} files`
            );

            // Upload files to current path
            api
              .uploadFiles(state.currentPath, files, (progress) => {
                progressTracker.update(progress);
              })
              .then(() => {
                progressTracker.complete();

                // Refresh directory listing
                navigateTo(state.currentPath);
              })
              .catch((error) => {
                progressTracker.error();
                console.error("Upload error:", error);
              });
          }
        }

        // Function to set up keyboard navigation between filter and checkboxes
        function setupCheckboxNavigation() {
          // Make checkboxes focusable
          function makeCheckboxesFocusable() {
            // Make select all checkbox focusable
            elements.selectAll.setAttribute("tabindex", "0");

            // Make all entry checkboxes focusable
            const entryCheckboxes = elements.fileList.querySelectorAll(
              'input[type="checkbox"]'
            );
            entryCheckboxes.forEach((checkbox) => {
              checkbox.setAttribute("tabindex", "0");

              // Add keyboard navigation for each checkbox
              checkbox.addEventListener("keydown", (e) => {
                if (e.key === "ArrowDown") {
                  e.preventDefault();
                  focusOnNextElement(checkbox);
                } else if (e.key === "ArrowUp") {
                  e.preventDefault();
                  focusOnPreviousElement(checkbox);
                }
              });
            });
          }

          // Add observer to make checkboxes focusable when file list updates
          const observer = new MutationObserver(() => {
            makeCheckboxesFocusable();
          });

          observer.observe(elements.fileList, { childList: true });

          // Initial setup
          makeCheckboxesFocusable();
        }

        // Function to focus on the next element in the navigation cycle
        function focusOnNextElement(currentElement) {
          // Get all focusable elements in order
          const focusableElements = getFocusableElements();

          // Find current element index
          const currentIndex = focusableElements.indexOf(currentElement);

          // Calculate next index (circular)
          const nextIndex = (currentIndex + 1) % focusableElements.length;

          // Focus on next element
          focusableElements[nextIndex].focus();
        }

        // Function to focus on the previous element in the navigation cycle
        function focusOnPreviousElement(currentElement) {
          // Get all focusable elements in order
          const focusableElements = getFocusableElements();

          // Find current element index
          const currentIndex = focusableElements.indexOf(currentElement);

          // Calculate previous index (circular)
          const prevIndex =
            (currentIndex - 1 + focusableElements.length) %
            focusableElements.length;

          // Focus on previous element
          focusableElements[prevIndex].focus();
        }

        // Function to get all focusable elements in the navigation cycle
        function getFocusableElements() {
          // Start with filter input
          const elements = [document.getElementById("filter-input")];

          // Add select all checkbox
          elements.push(document.querySelector('th input[type="checkbox"]'));

          // Add all visible entry checkboxes
          const entryCheckboxes = Array.from(
            document.querySelectorAll('tbody input[type="checkbox"]')
          );
          elements.push(...entryCheckboxes);

          // Filter out any null elements
          return elements.filter((el) => el !== null);
        }

        // Start the application
        init();
      });
    </script>
  </body>
</html>
